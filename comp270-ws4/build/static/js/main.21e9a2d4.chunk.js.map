{"version":3,"sources":["components/PhongShader.js","components/SpinningSphere.js","components/images/whitedot.png","components/Points.js","components/Ring.js","components/RingPlanet.js","components/AnimationCanvas.js","App.js","reportWebVitals.js","index.js"],"names":["PhongShader","props","fragmentShader","color","data","useMemo","uniforms","Ka","value","THREE","Kd","Ks","LightIntensity","LightPosition","Shininess","shininess","vertexShader","attach","wireframe","phiLength","Math","PI","thetaLength","SpinningSphere","mesh","useRef","useFrame","current","rotation","x","y","position","ref","args","scale","width","height","Points","count","t","f","graph","useCallback","z","sin","imageTexture","useLoader","whitedot","bufferRef","positions","xi","zi","push","Float32Array","array","i","needsUpdate","attachObject","length","itemSize","meshStandardMaterial","map","size","sizeAttenuation","transparent","alphaTest","opacity","Ring","ringColor","RingPlanet","ringShininess","planetColor","planetShininess","lightposition","cameraStartPosition","sunLightPosition","sunPosition","sunColor","ringPlanetPosition","ringPlanetLightPosition","AnimationCanvas","colorManagement","camera","fov","angle","Stars","OrbitControls","PerspectiveCamera","intensity","wireframes","App","className","fallback","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.21e9a2d4.chunk.js","sourcesContent":["// info on Phong shader https://en.wikipedia.org/wiki/Phong_reflection_model\n//help from https://codesandbox.io/embed/react-three-fiber-custom-geometry-with-fragment-shader-material-vxswf\nimport React from 'react';\nimport { useMemo } from 'react';\nimport * as THREE from 'three';\n\nconst PhongShader = (props) => {\n\n    //OpenGL fragment shader code\n    const fragmentShader = `\n    varying vec3 Normal;\n    varying vec3 Position;\n  \n    uniform vec3 Ka;  // ambient reflection ratio\n    uniform vec3 Kd;  // incoming light diffuse reflection ratio\n    uniform vec3 Ks;    // Specular (shiny) term of incmong light reflection ratio\n    uniform vec4 LightPosition; \n    uniform vec3 LightIntensity;\n    uniform float Shininess;\n  \n    vec3 phong() {\n      vec3 n = normalize(Normal); //normal at this point on surface\n      vec3 s = normalize(vec3(LightPosition) - Position);\n      vec3 v = normalize(vec3(-Position)); //direction pointing towards the viewer\n      vec3 r = reflect(-s, n); //direction of a perfect reflection\n  \n      //\n      vec3 ambient = Ka;\n      vec3 diffuse = Kd * max(dot(s, n), 0.0);\n      vec3 specular = Ks * pow(max(dot(r, v), 0.0), Shininess);\n  \n      return LightIntensity * (ambient + diffuse + specular);\n    }\n    void main() {\n      \n      vec3 color = vec3(${props.color});\n      gl_FragColor = vec4(color * phong(), 1.0);\n  }`\n  \n  const vertexShader = `\n    varying vec3 Normal;\n    varying vec3 Position;\n  \n    void main() {\n      Normal = normalize(normalMatrix * normal);\n      Position = vec3(modelViewMatrix * vec4(position, 1.0));\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `\n    const data = useMemo(\n    () => ({\n      \n      uniforms: {\n        Ka: { value: new THREE.Vector3(1, 1, 1) },\n        Kd: { value: new THREE.Vector3(1, 1, 1) },\n        Ks: { value: new THREE.Vector3(1, 1, 1) },\n        LightIntensity: { value: new THREE.Vector4(0.3, 0.3, 0.3, 1.0) },\n        LightPosition: { value: new THREE.Vector4(0, 0, 2000.9, 1.0) },\n        Shininess: { value: props.shininess }\n      }\n      ,\n      fragmentShader\n      ,\n      vertexShader\n    }),\n    []\n  )\n  return (\n    <shaderMaterial attach=\"material\" {...data}  wireframe={props.wireframe} color={props.color} />\n  )\n}\n\nexport default PhongShader;","import React, { useRef } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport PhongShader from './PhongShader';\n\n// sphere buffer geometry variables\nlet phiStart = 0;\nlet phiLength = Math.PI *2\nlet thetaStart = 0;\nlet thetaLength = Math.PI;\n\n//mesh rotation increment\nlet rotationIncrement = 0.001;\n\n// returns a spinning with variables coming in from the call location, phong shader component is attached\n\nconst SpinningSphere = (props) => {\n  const mesh = useRef(null);\n  useFrame(()=>(mesh.current.rotation.x = mesh.current.rotation.y += rotationIncrement));\n  return (    \n    <mesh position={props.position} ref={mesh}>\n      <sphereBufferGeometry args={[props.scale, props.width, props.height, phiStart, phiLength, thetaStart, thetaLength]}/>\n        <meshStandardMaterial wireframe={props.wireframe} /> \n      <PhongShader attach=\"material\" wireframe={props.wireframe} color={props.color} shininess={props.shininess}/>\n    </mesh>\n  )\n}\n\nexport default SpinningSphere;","export default __webpack_public_path__ + \"static/media/whitedot.ec08c55d.png\";","//help from this guide on ripple effect https://www.youtube.com/watch?v=wRmeFtRkF-8&ab_channel=AlvanCalebArulandu\nimport React, { useRef } from 'react';\nimport whitedot from './images/whitedot.png'\nimport { useLoader, useFrame } from '@react-three/fiber';\nimport { useMemo, useCallback } from 'react';\nimport * as THREE from 'three';\n\n\nlet dotSize = 2;\nlet dotSizeAttenuation = false;\nlet dotTransparent = true;\nlet dotAlphaTest = 1;\nlet dotOpacity = 1;\n\nconst Points = () => {\n    let count = 250;  // amount of points along 1 axis of the grid\n    let seperation = 2; //distance between points\n    let t = 0;   //phase shift;\n    let f = 0.0005;   //frequency\n    let a = 10;   //amplitude\n    let timeSpeed = 40; \n    let positionSteps = 1;\n    let positionIncrements = 3;\n  \n    //graph for sin wave animation on points\n    const graph = useCallback((x, z) => {\n      return Math.sin(f * ( x**2 + z**2 + t)) * a;\n    }, [t, f, a])\n  \n    //set up texture (dot image)\n    const imageTexture = useLoader(THREE.TextureLoader, whitedot);\n    // set up reference\n    const bufferRef = useRef();\n    //nested loop for dot positions\n    let positions = useMemo(()=> {\n        //initialize empty dot array\n        let positions = []\n        //outer loop x axis increment\n        for(let xi = 0; xi < count; xi++){\n            //inner loop z axis increment\n            for(let zi = 0; zi < count; zi++){\n                // set x , z\n                let x = seperation * (xi - count / 2);\n                let z = seperation * (zi - count / 2);\n                // x , z ranges = (-count min, +count max)  \n                // set y to memo graph for sin animation\n                let y = graph(x, z);                    \n                // apply positions to axes\n                positions.push(x, y, z);                \n            }\n        }      \n        return new Float32Array(positions);\n    }, [count, seperation, graph])   //dependencies from useMemo\n    //animation\n    useFrame(()=> {  \n      t-=timeSpeed;\n      // get positions from bufferRef\n      const positions = bufferRef.current.array;\n      //positionIncrement variable start point\n      let i = 0  \n      // nested for loop to iterate throuigh position / 2 to pass into the graph to animate\n      for(let xi = 0; xi < count; xi++){\n        for(let zi = 0; zi < count; zi++){\n            let x = seperation * (xi - count / 2);\n            let z = seperation * (zi - count / 2);    \n\n            //pass to animation graph\n            positions[i + positionSteps] = graph(x, z);\n\n            //increment i \n            i += positionIncrements;            \n        }\n      }      \n      bufferRef.current.needsUpdate = true ;\n    })\n    \n    return(\n        <points>      \n            <bufferGeometry attach=\"geometry\">\n            <bufferAttribute attachObject={['attributes', 'position']}\n            ref={bufferRef}\n            array={positions}\n            count = {positions.length / 3}\n            itemSize={3}\n            />\n            </bufferGeometry>  \n            <pointsMaterial attach=\"material\"\n            meshStandardMaterial={imageTexture}\n            map={imageTexture}\n            color={0x03A062}\n            size={dotSize}\n            sizeAttenuation={dotSizeAttenuation}\n            transparent={dotTransparent}\n            alphaTest={dotAlphaTest}\n            opacity={dotOpacity} />\n        </points>\n    )\n  }\n\n export default Points;","import React, { useRef } from 'react';\nimport PhongShader from './PhongShader';\nimport { useFrame } from '@react-three/fiber';\n\n// sphere geometry variables\nlet radius = 1.4;\nlet widthSegments = 30;\nlet heightSegments = 5;\nlet phiStart = 3;\nlet phiLength = 7;\nlet thetaStart = 1.5;\nlet thetaLength = 0.2;\n\n// mesh rotatation increments\nlet roatationXincrement = 0.0051;\nlet roatationYincrement = 0.0;\nlet rotationZincrement = 0.0001;\n\n// returns the ring used to build the ring planet with variables coming in from the call location\n\nfunction Ring(props) {\n  const mesh = useRef(null);\n  useFrame(()=>(mesh.current.rotation.y = mesh.current.rotation.y += roatationXincrement, mesh.current.rotation.x += roatationYincrement, mesh.current.rotation.z -= rotationZincrement))\n    return ( \n      <mesh  position={props.position} ref={mesh}>\n        <sphereBufferGeometry args={[radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength]} />\n          <meshStandardMaterial /> \n        <PhongShader color={props.ringColor} shininess={props.shininess} wireframe={props.wireframe} />\n      </mesh>     \n    )\n}\n\nexport default Ring;","import React from 'react';\nimport SpinningSphere from './SpinningSphere';\nimport Ring from './Ring';\n\n// returns the 'ring planet' as a whole by grouping the ring and spinning sphere components.\n\nconst RingPlanet = (props) => {\n    return (\n        <>\n        <Ring position={props.position} wireframe={props.wireframe} ringColor={props.ringColor} shininess={props.ringShininess}/>\n        <SpinningSphere position={props.position} color={props.planetColor} shininess={props.planetShininess} wireframe={props.wireframe} width={props.width} height={props.height} lightposition={props.lightposition}/>\n        </>\n    )\n}\n\nexport default RingPlanet","import React from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { PerspectiveCamera, OrbitControls, Stars } from '@react-three/drei'\nimport SpinningSphere from './SpinningSphere';\nimport Points from './Points';\nimport RingPlanet from './RingPlanet';\n\n// camera variables\nlet cameraStartPosition = [150, 50, 0];\nlet cameraFieldOfView = 75;\nlet cameraStartAngle = 90;\n\n//light variables\nlet lightIntensity = 10;\nlet lightScale = 10;\n\n//sun variables\nlet sunLightPosition = [0.0, 0.0, 0.0, 1.0]\nlet sunScale = 50;\nlet sunPosition = [0, 75, 0]\nlet sunShininess = 5;\nlet sunColor = [5.0, 1.0, 0.0]\n\n//planet variables\nlet ringPlanetPosition = [145,50, 0]\nlet ringPlanetLightPosition = [0.0, 2000.0, 0.0, 1.0]\nlet planetShininess = 5;\nlet ringShininess = 5;\nlet ringColor = [1.5, 1.5, 7.0]\nlet planetColor = [1.0, 1.0, 5.0]\n\nconst AnimationCanvas = (props) => {\n    return(\n    //set up the canvas\n      <Canvas colorManagement camera={{position: cameraStartPosition, fov:cameraFieldOfView}} angle={cameraStartAngle}>        \n        <Stars />\n        <OrbitControls />\n        <PerspectiveCamera />\n        <pointLight position={sunPosition} intensity={lightIntensity} scale={lightScale}/>\n        <SpinningSphere position={sunPosition} scale={sunScale} color={sunColor} shininess={sunShininess}\n            wireframe={props.wireframes} lightposition={sunLightPosition}/>\n        <RingPlanet position={ringPlanetPosition} wireframe={props.wireframes} lightposition={ringPlanetLightPosition}\n          ringColor={ringColor} planetColor={planetColor} planetShininess={planetShininess} ringShininess={ringShininess}/>\n        <Points />\n      </Canvas>\n  )\n}\n\nexport default AnimationCanvas;","import React from 'react';\nimport \"./App.css\"\nimport { Suspense } from 'react';\nimport AnimationCanvas from './components/AnimationCanvas';\n\n// sets all shapes to wireframes if true\nlet wireframes = false;\n\n// suspense component allows a fallback while it loads\nconst App = () => {  \n    return(\n    <div className=\"anim\">       \n      <Suspense fallback={<div>Loading...</div>}>\n        <AnimationCanvas width={15} height={15} wireframes={wireframes}>\n        </AnimationCanvas>\n       </Suspense>\n      </div>\n      )\n  \n}\n\nexport default App; \n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}