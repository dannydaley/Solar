[{"/home/danny/Documents/Programming/Solar/src/index.js":"1","/home/danny/Documents/Programming/Solar/src/App.js":"2","/home/danny/Documents/Programming/Solar/src/reportWebVitals.js":"3","/home/danny/Documents/Programming/Solar/src/components/AnimationCanvas.js":"4","/home/danny/Documents/Programming/Solar/src/components/SpinningSphere.js":"5","/home/danny/Documents/Programming/Solar/src/components/RingPlanet.js":"6","/home/danny/Documents/Programming/Solar/src/components/Points.js":"7","/home/danny/Documents/Programming/Solar/src/components/PhongShader.js":"8","/home/danny/Documents/Programming/Solar/src/components/Ring.js":"9"},{"size":500,"mtime":1682691443257,"results":"10","hashOfConfig":"11"},{"size":2324,"mtime":1682691443257,"results":"12","hashOfConfig":"11"},{"size":362,"mtime":1682691443257,"results":"13","hashOfConfig":"11"},{"size":2151,"mtime":1682691443257,"results":"14","hashOfConfig":"11"},{"size":990,"mtime":1682691443257,"results":"15","hashOfConfig":"11"},{"size":646,"mtime":1682691443257,"results":"16","hashOfConfig":"11"},{"size":3698,"mtime":1682691443257,"results":"17","hashOfConfig":"11"},{"size":2300,"mtime":1682691443257,"results":"18","hashOfConfig":"11"},{"size":1151,"mtime":1682691443257,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","suppressedMessages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1p15w31",{"filePath":"23","messages":"24","suppressedMessages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","suppressedMessages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","suppressedMessages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"32","messages":"33","suppressedMessages":"34","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","suppressedMessages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"38","messages":"39","suppressedMessages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41"},{"filePath":"42","messages":"43","suppressedMessages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45"},{"filePath":"46","messages":"47","suppressedMessages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49"},"/home/danny/Documents/Programming/Solar/src/index.js",[],[],"/home/danny/Documents/Programming/Solar/src/App.js",[],[],"/home/danny/Documents/Programming/Solar/src/reportWebVitals.js",[],[],"/home/danny/Documents/Programming/Solar/src/components/AnimationCanvas.js",[],[],"/home/danny/Documents/Programming/Solar/src/components/SpinningSphere.js",[],[],"/home/danny/Documents/Programming/Solar/src/components/RingPlanet.js",[],[],"/home/danny/Documents/Programming/Solar/src/components/Points.js",["50"],[],"//help from this guide on ripple effect https://www.youtube.com/watch?v=wRmeFtRkF-8&ab_channel=AlvanCalebArulandu\nimport React, { useRef } from \"react\";\nimport whitedot from \"./images/whitedot.png\";\nimport { useLoader, useFrame } from \"@react-three/fiber\";\nimport { useMemo, useCallback } from \"react\";\nimport * as THREE from \"three\";\n\nlet dotSize = 2;\nlet dotSizeAttenuation = false;\nlet dotTransparent = true;\nlet dotAlphaTest = 1;\nlet dotOpacity = 1;\n\nconst Points = (props) => {\n    let count = 250; // amount of points along 1 axis of the grid\n    let seperation = 2; //distance between points\n    let t = 0; //phase shift;\n    let f = 0.0005; //frequency\n    let a = 10; //amplitude\n    let timeSpeed = useRef(document.getElementById(\"waveSpeedSlider\").value); // DEPRECATED AND REPLACED BY SLIDER AND STATE IN APP JS\n    let positionSteps = 1;\n    let positionIncrements = 3;\n\n    //graph for sin wave animation on points\n    const graph = useCallback(\n        (x, z) => {\n            return Math.sin(f * (x ** 2 + z ** 2 + t)) * a;\n        },\n        [t, f, a]\n    );\n\n    //set up texture (dot image)\n    const imageTexture = useLoader(THREE.TextureLoader, whitedot);\n    // set up reference\n    const bufferRef = useRef();\n    //nested loop for dot positions\n    let positions = useMemo(() => {\n        //initialize empty dot array\n        let positions = [];\n        //outer loop x axis increment\n        for (let xi = 0; xi < count; xi++) {\n            //inner loop z axis increment\n            for (let zi = 0; zi < count; zi++) {\n                // set x , z\n                let x = seperation * (xi - count / 2);\n                let z = seperation * (zi - count / 2);\n                // x , z ranges = (-count min, +count max)\n                // set y to memo graph for sin animation\n                let y = graph(x, z);\n                // apply positions to axes\n                positions.push(x, y, z);\n            }\n        }\n        return new Float32Array(positions);\n    }, [count, seperation, graph]); //dependencies from useMemo\n    //animation\n    useFrame(() => {\n        t -= props.waveSpeed;\n        // t -= timeSpeed.current;\n        // get positions from bufferRef\n        const positions = bufferRef.current.array;\n        //positionIncrement variable start point\n        let i = 0;\n        // nested for loop to iterate throuigh position / 2 to pass into the graph to animate\n        for (let xi = 0; xi < count; xi++) {\n            for (let zi = 0; zi < count; zi++) {\n                let x = seperation * (xi - count / 2);\n                let z = seperation * (zi - count / 2);\n\n                //pass to animation graph\n                positions[i + positionSteps] = graph(x, z);\n\n                //increment i\n                i += positionIncrements;\n            }\n        }\n        bufferRef.current.needsUpdate = true;\n    });\n\n    return (\n        <points>\n            <bufferGeometry attach=\"geometry\">\n                <bufferAttribute\n                    attachObject={[\"attributes\", \"position\"]}\n                    ref={bufferRef}\n                    array={positions}\n                    count={positions.length / 3}\n                    itemSize={3}\n                />\n            </bufferGeometry>\n            <pointsMaterial\n                attach=\"material\"\n                meshStandardMaterial={imageTexture}\n                map={imageTexture}\n                color={0x03a062}\n                size={dotSize}\n                sizeAttenuation={dotSizeAttenuation}\n                transparent={dotTransparent}\n                alphaTest={dotAlphaTest}\n                opacity={dotOpacity}\n            />\n        </points>\n    );\n};\n\nexport default Points;\n","/home/danny/Documents/Programming/Solar/src/components/PhongShader.js",["51"],[],"// info on Phong shader https://en.wikipedia.org/wiki/Phong_reflection_model\n//help from https://codesandbox.io/embed/react-three-fiber-custom-geometry-with-fragment-shader-material-vxswf\nimport React from 'react';\nimport { useMemo } from 'react';\nimport * as THREE from 'three';\n\nconst PhongShader = (props) => {\n\n    //OpenGL fragment shader code\n    const fragmentShader = `\n    varying vec3 Normal;\n    varying vec3 Position;\n  \n    uniform vec3 Ka;  // ambient reflection ratio\n    uniform vec3 Kd;  // incoming light diffuse reflection ratio\n    uniform vec3 Ks;    // Specular (shiny) term of incmong light reflection ratio\n    uniform vec4 LightPosition; \n    uniform vec3 LightIntensity;\n    uniform float Shininess;\n  \n    vec3 phong() {\n      vec3 n = normalize(Normal); //normal at this point on surface\n      vec3 s = normalize(vec3(LightPosition) - Position);\n      vec3 v = normalize(vec3(-Position)); //direction pointing towards the viewer\n      vec3 r = reflect(-s, n); //direction of a perfect reflection\n  \n      //\n      vec3 ambient = Ka;\n      vec3 diffuse = Kd * max(dot(s, n), 0.0);\n      vec3 specular = Ks * pow(max(dot(r, v), 0.0), Shininess);\n  \n      return LightIntensity * (ambient + diffuse + specular);\n    }\n    void main() {\n      \n      vec3 color = vec3(${props.color});\n      gl_FragColor = vec4(color * phong(), 1.0);\n  }`\n  \n  const vertexShader = `\n    varying vec3 Normal;\n    varying vec3 Position;\n  \n    void main() {\n      Normal = normalize(normalMatrix * normal);\n      Position = vec3(modelViewMatrix * vec4(position, 1.0));\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `\n    const data = useMemo(\n    () => ({\n      \n      uniforms: {\n        Ka: { value: new THREE.Vector3(1, 1, 1) },\n        Kd: { value: new THREE.Vector3(1, 1, 1) },\n        Ks: { value: new THREE.Vector3(1, 1, 1) },\n        LightIntensity: { value: new THREE.Vector4(0.3, 0.3, 0.3, 1.0) },\n        LightPosition: { value: new THREE.Vector4(0, 0, 2000.9, 1.0) },\n        Shininess: { value: props.shininess }\n      }\n      ,\n      fragmentShader\n      ,\n      vertexShader\n    }),\n    []\n  )\n  return (\n    <shaderMaterial attach=\"material\" {...data}  wireframe={props.wireframe} color={props.color} />\n  )\n}\n\nexport default PhongShader;","/home/danny/Documents/Programming/Solar/src/components/Ring.js",["52"],[],"import React, { useRef } from 'react';\nimport PhongShader from './PhongShader';\nimport { useFrame } from '@react-three/fiber';\n\n// sphere geometry variables\nlet radius = 1.4;\nlet widthSegments = 30;\nlet heightSegments = 5;\nlet phiStart = 3;\nlet phiLength = 7;\nlet thetaStart = 1.5;\nlet thetaLength = 0.2;\n\n// mesh rotatation increments\nlet roatationXincrement = 0.0051;\nlet roatationYincrement = 0.0;\nlet rotationZincrement = 0.0001;\n\n// returns the ring used to build the ring planet with variables coming in from the call location\n\nfunction Ring(props) {\n  const mesh = useRef(null);\n  useFrame(()=>(mesh.current.rotation.y = mesh.current.rotation.y += roatationXincrement, mesh.current.rotation.x += roatationYincrement, mesh.current.rotation.z -= rotationZincrement))\n    return ( \n      <mesh  position={props.position} ref={mesh}>\n        <sphereBufferGeometry args={[radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength]} />\n          <meshStandardMaterial /> \n        <PhongShader color={props.ringColor} shininess={props.shininess} wireframe={props.wireframe} />\n      </mesh>     \n    )\n}\n\nexport default Ring;",{"ruleId":"53","severity":1,"message":"54","line":20,"column":9,"nodeType":"55","messageId":"56","endLine":20,"endColumn":18},{"ruleId":"57","severity":1,"message":"58","line":66,"column":5,"nodeType":"59","endLine":66,"endColumn":7,"suggestions":"60"},{"ruleId":"61","severity":1,"message":"62","line":23,"column":89,"nodeType":"63","messageId":"64","endLine":23,"endColumn":90},"no-unused-vars","'timeSpeed' is assigned a value but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useMemo has missing dependencies: 'fragmentShader', 'props.shininess', and 'vertexShader'. Either include them or remove the dependency array.","ArrayExpression",["65"],"no-sequences","Unexpected use of comma operator.","SequenceExpression","unexpectedCommaExpression",{"desc":"66","fix":"67"},"Update the dependencies array to be: [fragmentShader, props.shininess, vertexShader]",{"range":"68","text":"69"},[2148,2150],"[fragmentShader, props.shininess, vertexShader]"]