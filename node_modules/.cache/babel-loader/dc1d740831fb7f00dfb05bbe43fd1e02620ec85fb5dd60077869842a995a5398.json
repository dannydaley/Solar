{"ast":null,"code":"import _objectSpread from\"/home/danny/Documents/Programming/Solar/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// info on Phong shader https://en.wikipedia.org/wiki/Phong_reflection_model\n//help from https://codesandbox.io/embed/react-three-fiber-custom-geometry-with-fragment-shader-material-vxswf\nimport React from'react';import{useMemo}from'react';import*as THREE from'three';import{jsx as _jsx}from\"react/jsx-runtime\";var PhongShader=function PhongShader(props){//OpenGL fragment shader code\nvar fragmentShader=\"\\n    varying vec3 Normal;\\n    varying vec3 Position;\\n  \\n    uniform vec3 Ka;  // ambient reflection ratio\\n    uniform vec3 Kd;  // incoming light diffuse reflection ratio\\n    uniform vec3 Ks;    // Specular (shiny) term of incmong light reflection ratio\\n    uniform vec4 LightPosition; \\n    uniform vec3 LightIntensity;\\n    uniform float Shininess;\\n  \\n    vec3 phong() {\\n      vec3 n = normalize(Normal); //normal at this point on surface\\n      vec3 s = normalize(vec3(LightPosition) - Position);\\n      vec3 v = normalize(vec3(-Position)); //direction pointing towards the viewer\\n      vec3 r = reflect(-s, n); //direction of a perfect reflection\\n  \\n      //\\n      vec3 ambient = Ka;\\n      vec3 diffuse = Kd * max(dot(s, n), 0.0);\\n      vec3 specular = Ks * pow(max(dot(r, v), 0.0), Shininess);\\n  \\n      return LightIntensity * (ambient + diffuse + specular);\\n    }\\n    void main() {\\n      \\n      vec3 color = vec3(\".concat(props.color,\");\\n      gl_FragColor = vec4(color * phong(), 1.0);\\n  }\");var vertexShader=\"\\n    varying vec3 Normal;\\n    varying vec3 Position;\\n  \\n    void main() {\\n      Normal = normalize(normalMatrix * normal);\\n      Position = vec3(modelViewMatrix * vec4(position, 1.0));\\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n    }\\n  \";var data=useMemo(function(){return{uniforms:{Ka:{value:new THREE.Vector3(1,1,1)},Kd:{value:new THREE.Vector3(1,1,1)},Ks:{value:new THREE.Vector3(1,1,1)},LightIntensity:{value:new THREE.Vector4(0.3,0.3,0.3,1.0)},LightPosition:{value:new THREE.Vector4(0,0,2000.9,1.0)},Shininess:{value:props.shininess}},fragmentShader:fragmentShader,vertexShader:vertexShader};},[]);return/*#__PURE__*/_jsx(\"shaderMaterial\",_objectSpread(_objectSpread({attach:\"material\"},data),{},{wireframe:props.wireframe,color:props.color}));};export default PhongShader;","map":{"version":3,"names":["React","useMemo","THREE","jsx","_jsx","PhongShader","props","fragmentShader","concat","color","vertexShader","data","uniforms","Ka","value","Vector3","Kd","Ks","LightIntensity","Vector4","LightPosition","Shininess","shininess","_objectSpread","attach","wireframe"],"sources":["/home/danny/Documents/Programming/Solar/src/components/PhongShader.js"],"sourcesContent":["// info on Phong shader https://en.wikipedia.org/wiki/Phong_reflection_model\n//help from https://codesandbox.io/embed/react-three-fiber-custom-geometry-with-fragment-shader-material-vxswf\nimport React from 'react';\nimport { useMemo } from 'react';\nimport * as THREE from 'three';\n\nconst PhongShader = (props) => {\n\n    //OpenGL fragment shader code\n    const fragmentShader = `\n    varying vec3 Normal;\n    varying vec3 Position;\n  \n    uniform vec3 Ka;  // ambient reflection ratio\n    uniform vec3 Kd;  // incoming light diffuse reflection ratio\n    uniform vec3 Ks;    // Specular (shiny) term of incmong light reflection ratio\n    uniform vec4 LightPosition; \n    uniform vec3 LightIntensity;\n    uniform float Shininess;\n  \n    vec3 phong() {\n      vec3 n = normalize(Normal); //normal at this point on surface\n      vec3 s = normalize(vec3(LightPosition) - Position);\n      vec3 v = normalize(vec3(-Position)); //direction pointing towards the viewer\n      vec3 r = reflect(-s, n); //direction of a perfect reflection\n  \n      //\n      vec3 ambient = Ka;\n      vec3 diffuse = Kd * max(dot(s, n), 0.0);\n      vec3 specular = Ks * pow(max(dot(r, v), 0.0), Shininess);\n  \n      return LightIntensity * (ambient + diffuse + specular);\n    }\n    void main() {\n      \n      vec3 color = vec3(${props.color});\n      gl_FragColor = vec4(color * phong(), 1.0);\n  }`\n  \n  const vertexShader = `\n    varying vec3 Normal;\n    varying vec3 Position;\n  \n    void main() {\n      Normal = normalize(normalMatrix * normal);\n      Position = vec3(modelViewMatrix * vec4(position, 1.0));\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `\n    const data = useMemo(\n    () => ({\n      \n      uniforms: {\n        Ka: { value: new THREE.Vector3(1, 1, 1) },\n        Kd: { value: new THREE.Vector3(1, 1, 1) },\n        Ks: { value: new THREE.Vector3(1, 1, 1) },\n        LightIntensity: { value: new THREE.Vector4(0.3, 0.3, 0.3, 1.0) },\n        LightPosition: { value: new THREE.Vector4(0, 0, 2000.9, 1.0) },\n        Shininess: { value: props.shininess }\n      }\n      ,\n      fragmentShader\n      ,\n      vertexShader\n    }),\n    []\n  )\n  return (\n    <shaderMaterial attach=\"material\" {...data}  wireframe={props.wireframe} color={props.color} />\n  )\n}\n\nexport default PhongShader;"],"mappings":"4HAAA;AACA;AACA,MAAO,CAAAA,KAAK,KAAM,OAAO,CACzB,OAASC,OAAO,KAAQ,OAAO,CAC/B,MAAO,GAAK,CAAAC,KAAK,KAAM,OAAO,CAAC,OAAAC,GAAA,IAAAC,IAAA,yBAE/B,GAAM,CAAAC,WAAW,CAAG,QAAd,CAAAA,WAAWA,CAAIC,KAAK,CAAK,CAE3B;AACA,GAAM,CAAAC,cAAc,i7BAAAC,MAAA,CA0BEF,KAAK,CAACG,KAAK,6DAEjC,CAEF,GAAM,CAAAC,YAAY,2RASjB,CACC,GAAM,CAAAC,IAAI,CAAGV,OAAO,CACpB,iBAAO,CAELW,QAAQ,CAAE,CACRC,EAAE,CAAE,CAAEC,KAAK,CAAE,GAAI,CAAAZ,KAAK,CAACa,OAAO,CAAC,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CACzCC,EAAE,CAAE,CAAEF,KAAK,CAAE,GAAI,CAAAZ,KAAK,CAACa,OAAO,CAAC,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CACzCE,EAAE,CAAE,CAAEH,KAAK,CAAE,GAAI,CAAAZ,KAAK,CAACa,OAAO,CAAC,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CACzCG,cAAc,CAAE,CAAEJ,KAAK,CAAE,GAAI,CAAAZ,KAAK,CAACiB,OAAO,CAAC,GAAG,CAAE,GAAG,CAAE,GAAG,CAAE,GAAG,CAAE,CAAC,CAChEC,aAAa,CAAE,CAAEN,KAAK,CAAE,GAAI,CAAAZ,KAAK,CAACiB,OAAO,CAAC,CAAC,CAAE,CAAC,CAAE,MAAM,CAAE,GAAG,CAAE,CAAC,CAC9DE,SAAS,CAAE,CAAEP,KAAK,CAAER,KAAK,CAACgB,SAAU,CACtC,CAAC,CAEDf,cAAc,CAAdA,cAAc,CAEdG,YAAY,CAAZA,YACF,CAAC,EAAC,CACF,EAAE,CACH,CACD,mBACEN,IAAA,kBAAAmB,aAAA,CAAAA,aAAA,EAAgBC,MAAM,CAAC,UAAU,EAAKb,IAAI,MAAGc,SAAS,CAAEnB,KAAK,CAACmB,SAAU,CAAChB,KAAK,CAAEH,KAAK,CAACG,KAAM,GAAG,CAEnG,CAAC,CAED,cAAe,CAAAJ,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}